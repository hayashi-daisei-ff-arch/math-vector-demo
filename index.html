<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ベクトル内積・外積デモ（点線平行四辺形）</title>
<style>
body { margin:0; overflow:hidden; }
#info {
    position:absolute; top:0; left:0;
    color:white; font-family:sans-serif;
    padding:10px; background-color: rgba(0,0,0,0.5);
}
#legend {
    position:absolute; bottom:10px; left:10px;
    color:white; font-family:sans-serif;
    padding:10px; background-color: rgba(0,0,0,0.5);
}
</style>
</head>
<body>
<div id="info">
<p>内積: 0</p>
<p>なす角: 0°</p>
<p>外積ベクトルの長さ: 0</p>
</div>
<div id="legend">
<p>赤：ベクトルA</p>
<p>緑：ベクトルB</p>
<p>青：外積ベクトルC</p>
<p>黄：内積の射影線</p>
<p>橙：2ベクトルからなる平行四辺形</p>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
document.body.appendChild(renderer.domElement);
renderer.setSize(window.innerWidth, window.innerHeight);

const vectorA = new THREE.Vector3(1,0,0);
const vectorB = new THREE.Vector3();
const arrowHelpers = {};
const infoElement = document.getElementById('info');
const dotText = infoElement.children[0];
const angleText = infoElement.children[1];
const crossLengthText = infoElement.children[2];

// 内積射影線（黄）
const projGeometry = new THREE.BufferGeometry();
projGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6),3));
const projLine = new THREE.Line(projGeometry, new THREE.LineBasicMaterial({color:0xffff00}));
projLine.renderOrder = 3;
scene.add(projLine);

// 平行四辺形（橙・点線化）
const paraGeometry = new THREE.BufferGeometry();
paraGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(15),3));
const paraMaterial = new THREE.LineDashedMaterial({ color:0xff8800, dashSize:0.05, gapSize:0.03 });
const paraLine = new THREE.Line(paraGeometry, paraMaterial);
paraLine.computeLineDistances(); // 点線用
paraLine.renderOrder = 0;
scene.add(paraLine);

camera.position.set(0,0.3,2);

// 矢印
arrowHelpers.A = new THREE.ArrowHelper(vectorA.clone().normalize(), new THREE.Vector3(), vectorA.length(), 0xff0000);
arrowHelpers.A.renderOrder = 1;
arrowHelpers.B = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(), 1, 0x00ff00);
arrowHelpers.B.renderOrder = 2;
arrowHelpers.C = new THREE.ArrowHelper(new THREE.Vector3(0,0,0), new THREE.Vector3(), 0, 0x0000ff);
arrowHelpers.C.renderOrder = 2;
scene.add(arrowHelpers.A);
scene.add(arrowHelpers.B);
scene.add(arrowHelpers.C);

window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

function updateVectorB(){
    const time = Date.now()*0.002;
    vectorB.set(Math.cos(time), Math.sin(time), 0);
    arrowHelpers.B.setDirection(vectorB.clone().normalize());
    arrowHelpers.B.setLength(vectorB.length());
}

function updateDotAndProjection(){
    const dot = vectorA.dot(vectorB);
    const angle = Math.acos(dot/(vectorA.length()*vectorB.length()));
    dotText.textContent = `内積: ${dot.toFixed(2)}`;
    angleText.textContent = `なす角: ${(angle*180/Math.PI).toFixed(1)}°`;

    const proj = vectorA.clone().multiplyScalar(dot/(vectorA.length()*vectorA.length()));
    projGeometry.attributes.position.setXYZ(0,0,0,0);
    projGeometry.attributes.position.setXYZ(1,proj.x,proj.y,proj.z);
    projGeometry.attributes.position.setXYZ(2,0,0,0);
    projGeometry.attributes.position.setXYZ(3,proj.x,proj.y,proj.z);
    projGeometry.attributes.position.needsUpdate = true;
}

function updateCrossAndParallelogram(){
    const cross = new THREE.Vector3().crossVectors(vectorA, vectorB);
    crossLengthText.textContent = `外積ベクトルの長さ: ${cross.length().toFixed(2)}`;
    arrowHelpers.C.setDirection(cross.clone().normalize());
    arrowHelpers.C.setLength(cross.length());

    const p1 = new THREE.Vector3(0,0,0);
    const p2 = vectorA.clone();
    const p3 = vectorA.clone().add(vectorB);
    const p4 = vectorB.clone();
    paraGeometry.attributes.position.setXYZ(0,p1.x,p1.y,p1.z);
    paraGeometry.attributes.position.setXYZ(1,p2.x,p2.y,p2.z);
    paraGeometry.attributes.position.setXYZ(2,p3.x,p3.y,p3.z);
    paraGeometry.attributes.position.setXYZ(3,p4.x,p4.y,p4.z);
    paraGeometry.attributes.position.setXYZ(4,p1.x,p1.y,p1.z);
    paraGeometry.attributes.position.needsUpdate = true;

    paraLine.computeLineDistances(); // 点線反映
}

function animate(){
    requestAnimationFrame(animate);
    updateVectorB();
    updateDotAndProjection();
    updateCrossAndParallelogram();
    renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
